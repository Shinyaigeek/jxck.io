---
title: Cookie の属性と適切な処理""
emoji: "📝"
type: "tech"
topics: ["cookie", "web"]
published: false
---

# Cookie の属性と適切な処理

前節では Cookie の基本的な挙動と、 Credential としての重要性を解説した。ここからは、 Credential つまり Session ID としての用途に注目し、実装上考慮すべき点について見ていく。

## Session ID の付与

まず Session ID として付与する場合に適切な値を考えると、ランダムで予測されない一意な値である必要があることが前節の解説からもわかるだろう。

HTTP の Cookie の仕様はあくまで Cookie の挙動を定義したものであり、「どんな値を付与するのが安全か」は仕様の範囲外だ。そうした場合に参照できるドキュメントとして OWASP がある。

- [Session Management - OWASP Cheat Sheet Series](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)

ここには、以下のような要件が書かれている。

- 最低でも 16byte 以上の長さ
- 暗号的に安全な乱数生成器で生成
- 一意性の担保
- etc


逆を言うとこうした要件を満たさない、短くて推測が容易な値を使ってしまうと、攻撃者が総当りで Cookie を付与したリクエストを送り(Bruteforce Attack)、たまたま本物に行き当たることで、その Session を盗む(Session Hijack)ことができてしまう。

しかし、通常 Session ID は開発者が自分で生成するのではなく、フレームワークなどが適切な値を生成し、多くの場合は自動で付与する作りになっているだろう。そうした信頼できる実装に管理を任せ、自分で生成ロジックを考えて実装するといったことはするべきではない。

:::details OWASP とは
OWASP(Open Web Application Security Project) は、主にセキュリティに関する普及と啓蒙をする団体であり、 Web セキュリティのベストプラクティスをまとめたチートシートを公開している。Session Management 以外にも色々書かれているので、 Web 開発者なら一読しておきたい。また将来的にこの本と OWASP のガイドで内容が食い違ったりしたら、 OWASP に従うべきだろう。

- [OWASP Cheat Sheet Series](https://cheatsheetseries.owasp.org)

また、 Cookie を Credential という点で認証認可の話も切り離せないものとなる。その場合は NIST が参考になるだろう。

NIST(National Institute of Standards and Technology) は、アメリカで多岐に渡る分野の技術標準の策定などをしている。その内容は、政府に収めるシステムが満たすべき要件として使われたりする権威のあるもので、内容も利用者の安全(ひいては国防)を守る観点でかなりきちんと書かれている。認証認可に関するものは以下だ。

- [NIST Special Publication 800-63-3](https://pages.nist.gov/800-63-3/sp800-63-3.html)

他にも IPA はじめ多くの組織がガイドラインやチェックリストを出しているが、少なくともこの 2 つだけは覚えておくと良いだろう。日本語訳も探せば出てくるが、翻訳の鮮度を確認してから読むことをオススメしたい。
:::


## Session ID 付与のタイミング

前節で解説した通り、EC サイトなどではログインする前からカートに商品を追加でき、決済の直前でユーザ認証が行われるようなフローがよくある。

カートに限らずどんなサービスでも、サービスへの最初のアクセスで Session ID をまず付与し、 Session を区別できるようにするのが一般的だ。

```http
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1024
Set-Cookie: session_id=YWxpY2U

<!doctype html>
...
```

買い物が済み決済をするためには、ユーザを認証を行いセッションとアカウントを紐づける。


```http
POST /login HTTP/1.1
Host: example.com
Content-Length: 32
Cookie: session_id=YWxpY2U

username=alice&password=xxxxxxxx
```

これにより `session_id=YWxpY2U` が Alice だと判明するため、この Session に Alice のアカウントを紐付ければ良いという解説をした。

しかし、このまま **単純に `YWxpY2U` に Alice を紐付ける実装には大きな落とし穴がある** のだ。



### Session Fixation 攻撃

もし Alice が送ってきた session_id が、サーバによって付与されたものではなく、悪意のある攻撃者によって Alice のクライアントに埋め込まれた値だったらどうなるだろうか?

まず攻撃者は、サービスにアクセスし session_id を受け取る。

```http
GET / HTTP/1.1
Host: exmaple.com
Content-Length: 256
Set-Cookie: YXR0YWNrZXI

<!doctype html>
```

この Session ID をなんらかの方法で Alice のクライアントに付与し、 Alice に認証をさせる。


```http
POST /login HTTP/1.1
Host: example.com
Content-Length: 32
# 攻撃者によって埋め込まれた値
Cookie: session_id=YXR0YWNrZXI

username=alice&password=xxxxxxxx
```

認証が正しく行われたことで、この `session_id=YXR0YWNrZXI` をその後 Alice と扱ってしまうと、埋め込んだ攻撃者はこの session_id の値を知っているため、認証が通った直後に Alice に成り済ますことができてしまう。


```http
# 攻撃者は Alice になりすませる
GET /accounts HTTP/1.1
Host: example.com
# Alice により認証された Session ID
Cookie: session_id=YXR0YWNrZXI
```

このように、攻撃者の指定した Cookie にアカウントを紐付けさせるこの攻撃を **Session Fixation 攻撃** と呼ぶ。

### Session Fixation 対策

Session Fixation 攻撃への対策は知られており、「 **認証が終わったら session_id を再生成する** 」ことで防ぐことができる。 Alice の Session ID を更新してしまえば、攻撃者は新しい Session ID を知らないためなり済ませないからだ。

しかし、それだけでは認証する前の Alice 操作は攻撃者に見えてしまう。もし認証前でもカートへの追加を許可し、それを Session Fixation から守るには、カートに追加するたびに Session ID を再生成するといった方法が考えられる。しかし、個人情報などを扱う前には必ず認証を挟むことが推奨され、カートへの追加も認証後でないとできないようにしている EC サイトもある。

「Alice のクライアントに任意の Cookie を保存するなんてできるのか?」と思うかもしれないが、それがどう可能かは後ほど解説する。先に言っておきたいのは(近年は昔よりは良くなりつつ有るが) Session Fixation を完璧に防ぐことは簡単ではないこと、言い方を変えると **クライアントが送ってくる Cookie は基本的には信用ならない** ことだ。

OWASP のガイドでは、「権限レベルが変わったら」Session ID を再生成すべきといった書き方をしているが、わかりやすく言うなら、サービスを作る中で「ここから先ユーザが処理を進めたとき、もし Session Fixation が発生していたらまずいな」と思う場面では、再度認証をはさみ、そのタイミングで Session Cookie を再生成しておくと良いだろう。大手のサービスで重要な操作(パスワーの変更 etc)の前に再度認証を挟む実装をよく見ると思う、どこで認証を挟んでいるかに注目してみると参考になるだろう。


# Cookie の属性

## Path 属性による範囲指定

先程のログインフォームからのリクエストは、よく見るとパスが `/login` でした。

このリクエストに対して Set-Cookie を返すと、その Cookie は、次からの `/login` よりも下のパスへのリクエストにしか送られません。これでは、例えば`/`や`/cart`などのパスへは送られず、 Alice であることがわからないため不便です。

session_id は大抵サイト全体での識別子なので、通常は Path 属性に`/`を指定することでサイト全体に対して送られるようにします。

```http
Set-Cookie: session_id=q1w2e3r4t5; Path=/;
```

逆にこれを用いて Path を狭い範囲に制限しようとする場合は注意が必要です。

例えば example.com 以下の `/alice` は Alice が管理するサービス`/bob`は Bob が管理するサービスがデプロイされ、それぞれが認証を提供するような構成を考えます。

`/alice`でログインしたユーザに以下の Cookie を付与したとします。

```http
# /alice からのレスポンス
Set-Cookie: session_id=q1w2e3r4t5; Path=/alice;
```

これは`/alice`にのみ送られ、`/bob`には送られません、しかし`/bob`は以下のようにレスポンスを返すことで、`/alice`宛の Cookie を改ざんすることが可能です。

```http
# /bob からのレスポンス
Set-Cookie: session_id=bad-cookie; Path=/alice;
```

```http
# /alice に送ってしまう
Cookie: session_id=bad-cookie
```

Bob は、 Alice のサービスのユーザに任意の Cookie を埋め込むことができました。 Cookie ヘッダは「どの Path で付与されたか」という情報をもたないため、 Alice はそれが埋め込まれたものかを判断できません。この session_id を Alice のサービスが認証後も継続して使ってしまうと、そこで先ほど説明した Session Fixation が成立してしまいます。

Path 属性はセキュリティを担保するための仕様ではないため、このように Path ごとにサービスが別れている場合、 Credential のために Cookie を使用するのは避けるべきです。

(注: 最近は減りましたが、共用レンタルサーバは実際にこうした構成で提供されていました、パスは `/~alice`, `/~bob` などが一般的)。

### Secure 属性と HTTPS への制限

平分である HTTP で通信すると、通信を盗聴された場合 Cookie ヘッダの値が漏洩する可能性があります。そうした攻撃を避けるためにも、 Cookie を用いた通信は暗号化が必須です。

このとき、「Cookie を使う URL だけ暗号化する」や、「一部だけ`http://`でのアクセスが可能」といった構成には注意が必要です。

まず、 Cookie は同じドメインに対して送られるため、ユーザをなんらかの方法で`http://`の URL にアクセスさせれば、盗聴できる可能性があります。そこで、 Cookie を付与する際に、 Secure 属性を付与し、暗号化されている経路でしか送らないようにクライアントに指示します。

```
Set-Cookie: session_id=q1w2e3r4t5; Path=/; Secure;
```

これで`http://`でアクセス可能な URL があっても、盗聴のリスクを減らすことができるでしょう。しかし、これだけでは防げない問題もあります。

例えば攻撃者は、`http://`でアクセスできる URL から盗聴ができなくても、通信を改ざんして以下のようなヘッダを追加し Cookie を付与することが可能です。

```
Set-Cookie: session_id=bad-cookie; Path=/; Secure;
```

このヘッダを受け取ったクライアントは Cookie を保存し、`https://`での通信にもこの Cookie を送ってしまいます。

```
Cookie: session_id=bad-cookie
```

Cookie ヘッダは`http://`と`https://`どちらで付与されたかという情報を持たないため、これが改ざんされた Cookie なのかを見分けることはできません。これも先ほどと同様、 Session Fixation 攻撃などに応用できます。

これは、`http://`へのリクエストを`https://`にリダイレクトするようにしても、最初の通信が狙われる場合があるため、 Session Fixation 対策だけでなく、 Preload HSTS などを併用することが望ましいでしょう。

(TODO: preload hsts はリンクだけ)

### Domain 属性の注意点

example.com から付与された Cookie は、デフォルトでは example.com にしか送られません。

しかし以下のように Domain 属性を指定すると、 example.com だけでなくそのサブドメインにも Cookie が送られるようになります。

```
Set-Cookie: session_id=q1w2e3r4t5; Path=/; Domain=example.com
```

直感的ではありませんが、以下の挙動に注意が必要です。

- Domain 属性を設定しなければ example.com にのみ送られる
- Domain=example.com を付与すると example.com のサブドメインにも送られる

つまり、 Domain 属性を付与することは、送られるドメインを制限するのではなく、むしろ広げていると言うことができます。

これは、例えば example.com 以下の alice.example.com は Alice が管理するサービス、 bob.example.com は Bob が管理するサービスがデプロイされ、それぞれが認証を提供するような構成を考えます。

先程の Cookie は alice.example.com や bob.example.com にも送られるため、ユーザの example.com への session_id が Alice や Bob に漏洩する可能性があります。

このことを考えると、基本的に Domain 属性はそのサブドメイン全てが管理下にあり、サブドメインに送られても良いと保証できる場合につけることができます。しかし、その保証は通常難しいため、基本的に Domain 属性は付けず、サブドメインでセッションを連携する場合は、別の方法(例えば SingleSignOn など)を検討する方が良いでしょう。

逆に bob.example.com が以下のように Doamin 属性を example.com にした Cookie を付与することで、本来ユーザが example.com に送る Cookie を改ざんすることもできます。

```
# bob.example.com からのレスポンス
Set-Cookie: session_id=bad-cookie; Path=/; Domain=example.com
```

```
# example.com や alice.example.com に送ってしまう
Cookie: session_id=bad-cookie
```

Cookie ヘッダは「どの Domain で付与されたか」という情報を持たないため、別のサブドメインで埋め込まれたかを判断できません。これも Session Fixation 攻撃などに応用できます。

このことからも、サブドメイン間でそれぞれが認証を提供しその提供者が違うといった構成を取るのは避けるほうが良いでしょう。

### Max-Age による有効期限

Cookie には有効期限があり、クライアントがその Cookie をいつまで送り続けるのかを`max-age`属性に秒数で指定します。

```
Set-Cookie: session_id=q1w2e3r4t5; Path=/; Max-Age=2592000
```

先程の Set-Cookie はこの指定がありませんでした、その場合 Cookie はブラウザが閉じると消えるという挙動になります。なお、昔は今と違い用が済むとブラウザをいちいち閉じていたため、ブラウザが閉じるまでをセッションと呼び、そこから仕様では有効期限を指定しない Cookie を、 Session Cookie と呼んでいます。

現在では、ブラウザを閉じても明示的にログアウトしなければセッションは維持されて欲しいため、 session_id には長い期間を指定するのが普通です。しかし、他のサイトの Cookie が増えていき、ブラウザに保存できる限界を超えると古いものから消されることがあるため、指定した時間確実に残ることは保証されません。通常一年以上を指定する意味はありません。

また、かつては Expire 属性に日付を指定し、そこまで有効にするという指定方法がありました。

```
Set-Cookie: session_id=q1w2e3r4t5; Path=/; Expires=Sun, 02 Feb 2020 02:02:02 GMT
```

しかし、 Expires は保存している OS の時間を元に計算されるため、 OS の時間設定をずらすことでごまかすことができるため、改善のために Max-Age が定義されました。現在のブラウザのほとんどは Max-Age に対応していますが、対応していないブラウザのために両方送るサービスもあります。

### HttpOnly と JS の API

Cookie は、 JS からアクセスすることもできます。
例えば、先程付与した session_id は、以下のように取得できます。

```js
document.cookie // "session_id=q1w2e3r4t5"
```

全体が文字列として取得され、好きに書き換えて代入しなおせば上書きすることができます。ここには属性も含めることが可能です。

```js
document.cookie = "Foo=Bar; Max-Age=1000; Path=/"
```

Max-Age や Path を指定することで、ページ遷移をまたいでもサイト全体で保存されるため、かつては LocalStorage の代わりに使われていました。

しかし、 XSS などにより意図しない JS が実行された場合、この API を用いて Cookie を窃取、改ざんすることが可能です。これを防ぐためには、 HttpOnly 属性をつけることで、その Cookie がサーバとの通信では送られるが、 JS ではアクセスできないようすることができます。

```js
Set-Cookie: session_id=q1w2e3r4t5; Path=/; HttpOnly;
```


LocalStorage が普及した現在、 Cookie の JS API を積極的に使う機会も減りました。特に session_id のような値には、 必ず HttpOnly を付与しましょう。


### SameSite Cookie

「Cookie はサイトをまたいでも自動で送られる」という挙動は CSRF や Timing Attack 以外にも様々な攻撃に応用できる可能性があります。

そこで、サイトを跨いだ Cookie の送信を制限するために提案されたのが Cookie の SameSite 属性です。 SameSite 属性には 3 つの値があります。

- Strict
- Lax
- None

まず、以下のように Strict を付与すると、その Cookie はサイトを跨ぐいかなるリクエストにも付与されなくなります。

```
Set-Cookie: session_id=q1w2e3r4t5; SameSite=Strict;
```

この設定ならば CSRF や Timing Attack の発生は、ほとんど防ぐことができます。しかし、 session_id にこれをつけてしまうと、別のサイトから遷移してきた場合にも Cookie が送られないため、毎回未ログインの状態になってしまいます。

そこで、画面遷移(正確には Top Level Navication)の場合にだけ、別のサイトからも Cookie を送り、 Form からの POST や、画像などサブリソースへのリクエストには付与しないよう緩和した設定が Lax です。

この設定でもかなりの攻撃が緩和されますが、この属性だけに依存したセキュリティ対策は推奨されません。 CSRF 対策には依然 Token を付与するなどの実装を行い、多層防御の一環としてこの設定の導入を検討しましょう。

一方で、安全側に倒す目的で、 Cookie の設定をデフォルトで Lax にするブラウザもあります。この場合 Set-Cookie に明示的に SameSite が付与されていなくても自動で Lax と扱われるため、多くの攻撃が未然に防がれる一方、これまで他のサイトにも Cookie が自動で送信されていることを前提に作られていたサイトは、壊れてしまう場合があります。

これを防ぐためには、サイトをまたいでも自動で送ってほしい Cookie に対し明示的に None を付与することで、これまでの挙動を維持します。

```
Set-Cookie: session_id=q1w2e3r4t5; SameSite=None;
```

以上を踏まえると、今後は基本的に`SameSite=Lax`を前提に開発を行い、それでは満たせない要件が有る場合に、セキュリティリリエスクを踏まえた上で明示的に`SameSite=None`を付与する設計を考慮すると良いでしょう。

### Cookie Prefixes

ここまで何度か解説したように、 Cookie は別のドメインやパス、 `http://`通信などによって書き換えられている可能性が常にあります。そして Cookie ヘッダにはどのような属性で保存された値なのかという情報が一切ありません。

```http
# Secure を指定して想定した正規のヘッダ
Set-Cookie: session_id=q1w2e3r4t5; Secure

# 改竄され Secure を消されたヘッダ
Set-Cookie: session_id=q1w2e3r4t5;

# どちらも同じ Cookie ヘッダで送られる
Cookie: session_id=q1w2e3r4t5
```

保存されている属性の値も一緒に送られてくれば確認できますが、今更 Cookie ヘッダの仕様を変えるわけにはいきません。そこで提案されたのが Cookie Prefix という仕様です。

まず、 Secure 属性が確実についていて欲しい Cookie は、その Cookie 名の頭に`__Secure-`という接頭辞をつけます。すると、ブラウザはその Cookie に Secure 属性がついていない場合は保存しなくなります。攻撃者が Prefix を外したら、サービスが知っているキーと変わってしまうため外すことはできません。

逆を言えば、ブラウザから送られてくる`__Secure-`がついた Cookie は、確実に Secure 属性がついており`https://`でしか送られていないことが保証できるのです。

```http
# 保存される
Set-Cookie: __Secure-session_id=q1w2e3r4t5; Secure

# 保存されない
Set-Cookie: __Secure-session_id=q1w2e3r4t5

# Secure 属性がついてることが保証される
Cookie: __Secure-session_id=q1w2e3r4t5
```

これをさらに強力にしたのが`__Host-`です。これは Secure 属性があり、 Path 属性が`/`で、 Doamin 属性が無い場合しか保存されなくなります。

```http
Set-Cookie: __Host-session_id=q1w2e3r4t5; Secure; Path=/;
```

送られてくる Cookie は、`http://`通信で送られたり、サブドメインに送られてないことが保証でき、まさしく session_id の用途に利用できます。

ブラウザが対応していない場合は、単にそういうヘッダ名な Cookie として扱われるだけなので、互換を壊さないため、導入の敷居は低く、改竄に対する対策に利用することができます。

### Cookie の削除と Clear-Site-Data

Cookie の削除には、長らく明示的な API がありませんでした。そこで、消したい Cookie の値を空にしつつ有効期限切れにするという方法がとられます。 session_id の場合は削除がセッションの終了になるため、ログアウト処理などで行われます。

```
Set-Cookie: session_id= Max-Age=0;
```

もし HttpOnly が付与されていない場合は、 JS の API から消すことも可能です。

```
document.cookie="session_id=; Max-Age=0"
```

最近では、明示的にブラウザが保存している情報を削除する`Clear-Site-Data`ヘッダが提案されており、実装が進んでいます。このヘッダは localStorage やブラウザキャッシュの削除なども含まれていますが、以下のように設定すればサイトに保存されている Cookie を全て削除することが可能です。

```http
Clear-Site-Data: "cookies"
```

### Cookie の用途と属性のまとめ

Cookie の用途は session_id だけではありません。例えばユーザごとの設定を保存する用途にも使用されてきました。

```http
# ユーザのテーマ設定の保存
Set-Cookie: theme=aqua
```

そうした設定も、リクエストに載せて送られてくることでサーバで分岐してレスポンスを変えることができますが、そうした情報もサーバ側で session_id に紐づいて保存されるか、 JS から扱いやすいように LocalStorage などに保存されるのが一般的になりました。

したがって Cookie の中心的な用途は session_id であり、その理想的な設定の一例は以下のようになるでしょう。

- 安全な乱数を元に生成した値を利用
- Path 属性を `/` にしサイト全体で利用
- Max-Age 属性を長めにして明示的にログアウトするまでセッションを維持
- Secure 属性を付与し https のみで送信されるように
- Domain 属性を付与せず、余計なサブドメインに送信しない
- HttpOnly 属性を付与し、 JS API からさわれないように
- SameSite 属性を Lax にし、画面遷移以外では別ドメインに送られないように

```http
Set-Cookie: __Host-session_id=q1w2e3r4t5; Path=/; Max-Age=2592000; Secure; HttpOnly; SameSite=Lax
```




























