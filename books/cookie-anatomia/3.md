---
title: "Cookie の属性と適切な処理"
emoji: "📝"
type: "tech"
topics: ["cookie", "web"]
published: false
---

# Cookie の属性と適切な処理

前節では Cookie の基本的な挙動と、 Credential としての重要性を解説した。ここからは、 Credential つまり Session ID としての用途に注目し、実装上考慮すべき点について見ていく。

## Cookie の仕様

まず Cookie の仕様についてだが、前節でも紹介したとおり最新の RFC として RFC6265 がある。

- [RFC 6265 - HTTP State Management Mechanism](https://tools.ietf.org/html/rfc6265)

しかしこの仕様も 2011 年に公開されたもので、その後に提案された新しい仕様や変更点も有り、それらは RFC6265bis という新しいドラフトで作業がされている。

- [draft-ietf-httpbis-rfc6265bis - Cookies: HTTP State Management Mechanism](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis)

執筆時点では draft-06 であり、これが今後も更新され、最後には RFC6265 の改訂版として RFC になるだろう。この改定仕様の中には、すでにブラウザに実装されているものもあり、これから Cookie の利用を考える上で把握しておくべき内容だ。したがって以降は 6265bis を踏まえたうえで解説していく。


## Session ID の要件

まず Session ID として付与する場合に適切な値を考えると、ランダムで予測されず使い捨てられる一意な値(Nonce)であるべきことが前節の解説からもわかるだろう。

HTTP の Cookie の仕様はあくまで Cookie の挙動を定義したものであり、「どんな値を付与するのが安全か」は仕様の範囲外だ。そうした場合に参照できるドキュメントとして OWASP がある。

- [Session Management - OWASP Cheat Sheet Series](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)

ここには、以下のような要件が書かれている。

- 最低でも 16byte 以上の長さ
- 暗号的に安全な乱数生成器で生成
- 一意性の担保
- etc

逆を言うとこうした要件を満たさない、短くて推測が容易な値を使ってしまうと、攻撃者が総当りで Cookie を付与したリクエストを送り(Bruteforce Attack)、たまたま本物に行き当たることで、その Session を盗む(Session Hijack)ことができてしまう。

しかし、通常 Session ID は開発者が自分で生成するのではなく、フレームワークなどが適切な値を生成し、多くの場合は自動で付与する作りになっているだろう。そうした信頼できる実装に管理を任せ、自分で生成ロジックを考えて実装するといったことはするべきではない。

:::details OWASP とは
OWASP(Open Web Application Security Project) は、主にセキュリティに関する普及と啓蒙をする団体であり、 Web セキュリティのベストプラクティスをまとめたチートシートを公開している。 Session Management 以外にも色々書かれているので、 Web 開発者なら一読しておきたい。また将来的にこの本と OWASP のガイドで内容が食い違ったりしたら、 OWASP に従うべきだろう。

- [OWASP Cheat Sheet Series](https://cheatsheetseries.owasp.org)

また、 Cookie を Credential とする点で認証認可の話も切り離せないものとなる。その場合は NIST が参考になるだろう。

NIST(National Institute of Standards and Technology) は、アメリカで多岐に渡る分野の技術標準の策定などをしている。その内容は、政府に収めるシステムが満たすべき要件として使われたりもする権威あるもので、内容も利用者の安全(ひいては国防)を守る観点でかなりきちんと書かれている。認証認可に関するものは以下だ。

- [NIST Special Publication 800-63-3](https://pages.nist.gov/800-63-3/sp800-63-3.html)

他にも IPA はじめ多くの組織がガイドラインやチェックリストを出しているが、少なくともこの 2 つだけは覚えておくと良いだろう。日本語訳も探せば出てくるが、翻訳の鮮度を確認してから読むことをオススメしたい。
:::


## Session ID 付与のタイミング

前節で解説した通り、 EC サイトなどではログインする前からカートに商品を追加でき、決済の直前でユーザ認証が行われるようなフローがよくある。

カートの有無に限らずどんなサービスでも、最初のアクセスで Session ID をまず付与し、 Session を区別できるようにするのが一般的だ。


```http
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1024
Set-Cookie: session_id=YWxpY2U

<!doctype html>
...
```

買い物が済み決済をするためには、ユーザ認証を行いセッションとアカウントを紐づける。


```http
POST /login HTTP/1.1
Host: example.com
Content-Length: 32
Cookie: session_id=YWxpY2U

username=alice&password=xxxxxxxx
```

これにより `session_id=YWxpY2U` が Alice だと判明するため、この Session に Alice のアカウントを紐付ければ良いという解説をした。

しかし、このまま **単純に `YWxpY2U` に Alice を紐付ける実装には大きな落とし穴がある** ため注意したい。


### Session Fixation 攻撃

もし Alice が送ってきた session_id が、サーバによって付与されたものではなく、悪意のある攻撃者によって Alice のクライアントに埋め込まれた値だったらどうなるだろうか?

まず攻撃者は、サービスにアクセスし session_id を受け取る。


```http
GET / HTTP/1.1
Host: exmaple.com
Content-Length: 256
Set-Cookie: YXR0YWNrZXI

<!doctype html>
```

この Session ID をなんらかの方法で Alice のクライアントに付与し、 Alice に認証をさせる。


```http
POST /login HTTP/1.1
Host: example.com
Content-Length: 32
# 攻撃者によって埋め込まれた値
Cookie: session_id=YXR0YWNrZXI

username=alice&password=xxxxxxxx
```

認証が正しく行われたことで、この `session_id=YXR0YWNrZXI` をその後 Alice と扱ってしまうと、埋め込んだ攻撃者はこの session_id の値を知っているため、認証が通った直後に Alice に成り済ますことができてしまう。


```http
# 攻撃者は Alice になりすませる
GET /accounts HTTP/1.1
Host: example.com
# Alice により認証された Session ID
Cookie: session_id=YXR0YWNrZXI
```

このように、攻撃者の指定した Cookie にアカウントを紐付けさせるこの攻撃を **Session Fixation 攻撃** と呼ぶ。


### Session Fixation 対策

Session Fixation 攻撃への対策は知られており、「 **認証が終わったら session_id を再生成する** 」ことで防ぐことができる。 Alice の Session ID を更新してしまえば、攻撃者は新しい Session ID を知らないため、なり済ませないからだ。

しかし、それだけでは認証する前の Seasion Fixation は防げず、Alice の操作は攻撃者に見えてしまう。もし認証前でもカートへの追加を許可し、それを Session Fixation から守るには、カートに追加するたびに Session ID を再生成するといった方法が考えられる。しかし、個人情報などを扱う前には必ず認証を挟むことが推奨され、カートへの追加も認証後でないとできないようにしている EC サイトもある。

「Alice のクライアントに任意の Cookie を保存するなんてできるのか?」と思うかもしれないが、それがどう可能かは後ほど解説する。先に言っておきたいのは(近年は昔よりは良くなりつつ有るが) Session Fixation を完璧に防ぐことは簡単ではないこと、もっと言えば **クライアントが送ってくる Cookie は基本的には信用ならない** ということだ。

OWASP のガイドでは、「権限レベルが変わったら」 Session ID を再生成すべきといった書き方をしているが、わかりやすく言うなら、サービスを作る中で「ここから先ユーザが処理を進めたとき、もし Session Fixation が発生していたらまずいな」と思う場面では再度認証をはさみ、そのタイミングで Session Cookie を再生成しておくと良いだろう。大手のサービスで重要な操作(パスワーの変更 etc)の前に再度認証を挟む実装をよく見ると思う、どこで認証を挟んでいるかに注目してみると参考になるだろう。

:::message alert
Cookie はサーバが付与し、サーバが知らない Cookie を勝手に送っても無視される、と普通なら思うだろう。驚くことに、世の中には「クライアントが送ってきた Cookie でサーバが知らない値でも、それをその後の Session ID として使ってしまう」という実装が存在することが知られている(Session Adoption)。
また、昔は 「Cookie を無効にしているユーザ」が存在し、そうしたユーザでも Session を確立するために Session ID を Cookie ではなく URL のパラメータに入れるという実装も存在した。
これらが組み合わさると、適当な Session ID を生成し、それをパラーメタに付与したリンクを対象者に踏ませれば、 Session Fixation は簡単にできてしまうことになる。
最近のフレームワークはさすがにこうした実装は無いと思うが、古いフレームワークなどが使われたサービスでは注意が必要だ。
:::


# Cookie の属性

ここまでの話で Credential としての Session Cookie は以下のようになることがわかる。


```http
Cookie: session_id=YWxpY2U
```

ここからは、この値に付与する属性を見ていこう。


## Path 属性による範囲指定


### Path 属性の設定

Cookie には Path という概念がある。例えば前節のように、認証のためのログインフォームが `/login` だったとする。


```http
POST /login HTTP/1.1
Host: example.com
Content-Length: 32

username=alice&password=xxxxxxxx
```

サーバは以下のようなレスポンスで Cookie を付与する。


```http
201 Created HTTP/1.1
Content-Length: 256
Content-Type: text/html
Set-Cookie: session_id=YWxpY2U

<!doctype html>
...
```

このとき、 `session_id` Cookie の Path は、デフォルトでリクエストした URL の Path つまり `/login` になり、ブラウザはこの Cookie を `/login` 以下の Path にしか送らない。従って、 `/` や `/cart` などのリクエストにこの Cookie は載らないため、このままではカートの識別は実現できない。

基本的に、 Session ID はサイト前提で利用することになるため、明示的に Path 属性にルートパスを指定する必要があるだろう。


```http
Set-Cookie: session_id=YWxpY2U; Path=/
```

この設定が基本となる。


### Path 属性の注意点

Path 属性は送信先を制限するものなので、セキュリティの観点から送信範囲を限定するために使うものと思うかもしれないが、その理解は半分危険だ。

例えば、 1 つのドメイン example.com 以下に、パスを区切って別々のユーザが好きなサービスを提供できるようなサービスがあったとしよう。

- https://example.com/alice : Alice が管理するサービス
- https://example.com/bob   : Bob   が管理するサービス

`/alice/login` には認証フォームがあり、ログインしたユーザに Cookie を付与する。この Cookie の Path を `/` などにしてしまっては `/bob` にも送られてしまうと、 Path を絞っているとしよう。


```http
# /alice からのレスポンス
Set-Cookie: session_id=YWxpY2U; Path=/alice;
```

これで Cookie は `/alice` にのみ送られ `/bob` には送られない。しかし `/bob` はこの Cookie を盗めなくても改竄はできる。

`/bob` のどこかで以下のようにレスポンスを返せば良い。


```http
# /bob からのレスポンス
Set-Cookie: session_id=bad-cookie; Path=/alice;
```

すると、 `/alice/login` で付与された正規の Cookie は Bob によって上書きされ、ブラウザは `/alice` に対してこの値を送ってしまうのだ。


```http
# /alice に送ってしまう
Cookie: session_id=bad-cookie
```

Bob は、 Alice のサービスのユーザに任意の Cookie を埋め込むことができた。 Path 属性は「どこに送るのか」を制限するだけなのでこの攻撃に無力だ。 Cookie はそもそも「 **どの Path で付与されたか** 」という情報は持たないため、 Alice はそれが「 **確かに自分が付与したものか、攻撃者に埋め込まれたものか** 」を判断できないのだ。

この session_id を Alice のサービスが認証後も継続して使ってしまうと、そこで先ほど説明した Session Fixation が成立してしまう。

つまり、「 **Cookie において Path は Origin のようなセキュリティの境界にはなりえない** 」ため、 Path ごとに Credential が別になる(つまり認証が違う)サービスを同居する構成はとってはならないのだ。

:::details レンタルサーバというユースケース
Alice と Bob が同じドメインの別のパスで別のサービスを提供するなんて普通しないだろ、と思うかもしれない。確かに今となっては普通はしない。しかし、クラウドよりも以前にあった「レンタルサーバ」と呼ばれていたサービスではこうした構成は存在した。 1 つの Linux サーバに複数の Linux User が作られれ、それぞれの Home ディレクトリ以下が HTTP サーバによって公開されている構成だ。

その場合 Alice / Bob のホームディレクトリは `~alice` `~bob` となるので、 URL も http://example.com/~alice や http://example.com/~bob となる。 Home 以下は好きにしてよいが sudo も使えないため、主に静的な HTML ファイルを置いたり、 CGI による掲示板を設置したりという用途が主流だったようだ。

今となってはユーザごとに VM が割り当てられ、何かをデプロイするにしても最低でサブドメインくらいは振られるのが主流になり、そうしたサービスはあまり使われなくなったが、 Web の黎明期にはそうした構成があった以上、仕様を考える上でそうしたユースケースの存在は無視できない。

仕様を読みながら「なんかよくわからない状況を前提に書かれているけど、そんな前提そもそも無いのでは?」と思った場合、「今はない」だけで「昔はあった」かもしれないという点には注意が必要だ。
:::



## Domain 属性による範囲指定

### Domain 属性の設定

example.com から付与された Cookie は、デフォルトでは example.com にしか送られない。

しかし以下のように Domain 属性を指定すると、 example.com だけでなくそのサブドメインにも Cookie が送られるようになる。

```
Set-Cookie: session_id=YWxpY2U; Path=/; Domain=example.com
```

この属性も、まるで送信範囲を明示的に制限しているように見えるが、 **挙動が直感的ではない** ため注意が必要だ。

- Domain 属性を設定しなければ example.com にのみ送られる
- Domain=example.com を付与すると example.com のサブドメインにも送られる

つまり、 Domain 属性を付与することは、送られるドメインを制限するのではなく、むしろ広げていると言うことができる。指定しないほうが送信される範囲が狭いのだ。


### Domain 属性の注意点

今度は、 example.com 以下の alice.example.com は Alice が管理するサービス、 bob.example.com は Bob が管理するサービスがデプロイされ、それぞれが認証を提供するような構成を考える。

alice.example.com で認証したレスポンスで以下の Set-Cookie が返ってきたとしよう。

```http
# alice.example.com からのレスポンス
Set-Cookie: session_id=YWxpY2U; Path=/; Domain=example.com
```

すると、この Cookie は bob.example.com にも送信されてしまうため、 Session ID の漏洩が発生し、 Bob は Alice のサービス利用者になりすますことができてしまう。

さらに Alice が Domain 属性をつけていなかったとしても、 Bob は以下のようなレスポンスを Alice のユーザに返すことができる。

```http
# bob.example.com からのレスポンス
Set-Cookie: session_id=bad-cookie; Path=/; Domain=example.com
```

この Cookie を持つユーザが alice.example.com にアクセスすると、 Bob が仕込んだ session_id を送る。この session_id を Alice のサービスが認証後も継続して使ってしまうと、ここでも Session Fixation が発生してしまうのだ。

Path 属性の時と同様、 Cookie ヘッダは「 **どの Domain で付与されたか** 」という情報を持たないため、「 **自分のドメインで付与されたものか、他のドメインで付与されたものか** 」を判断できない。このことからも、 **サブドメイン間でそれぞれ認証や権限レベルが違う** といった構成を取るのは推奨されない。

結果として Session Cookie には **Domain 属性は付与しない** のが推奨されており、もしサブドメイン間で Session や Session 以外の Cookie を共有したい場合などは、別途共有方法を考えるのが理想となる。

```http
# ここまでの理想の設定(id は短くしている)
Set-Cookie: session_id=YWxpY2U; Path=/;
```


## Registerable Doamin と Public Suffix List

`Domain=example.com` とすると example.com のサブドメインに Cookie が送られるという解説をしたが、ここで `Domain=com` と指定したとしても *.com に送られるわけがない。といいたいところだが、信じられないことにこれは実際に発生したことがある。

日本には都道府県型 JP ドメインというものがあり、例えば tokyo.jp のサブドメインを取得することができる。そのドメインから IE に対して、そのサブドメインのサーバで `Domain=tokyo.jp` な Cookie を付与することができたのだ。これは Cookie Monster バグと呼ばれている。

単なる IE のバグだと考えればそれでもいいが、そもそもなぜこうしたことが起こったのかは、そもそも「Domain」というものが、どう定義されどう運用されているかを一度知っておくと良いだろう。その考え方は今後も重要になる。

### Top Level Domain と Registerable Domain

例えば `.jp` について考えてみよう、 `.jp` は Top Level Domain (TLD) と呼ばれ、我々は `.jp` のサブドメインにあたる部分をドメインレジストラから購入することができる。ここでは例示ドメインだとややこしいので `${好きな単語}.jp` のようなイメージで考えて欲しい。そして、この購入できるドメインを Registerable Domain という。

一方、 `.co.jp` というドメインもあり、 `${好きな単語}.co.jp` も取得できる。しかし、 `co.jp` というドメインは取得できない。つまり、ドメインは `.` で分けたとき最後が TLD でそこに単語を足せば Registerable Domain になる。というほど簡単ではない。そして最後がどういう組み合わせだと取得できなくて、どうなっていれば取得できるのかは、ドメインの運用によってバラバラなのだ。

都道府県型 JP ドメインを考えると、 `${好きな単語}.jp` は取得できるが、 `tokyo.jp` は取得できず、 `${好きな単語}.tokyo.jp` は取得できる。これは `tokyo.jp` をレジストラがそう運用しているから、という運用の都合なのだ。

### Effective Top Level Domain と Public Suffix List

これはつまり、 `tokyo.jp` はまるでその組み合わせが Top Level Domain のような扱いをしないといけないことを意味する。そうしたドメインの組み合わせを Effective Top Level Domain (eTLD) と呼ぶ。

この eTLD は何度も言うように機械的に決まっているわけではなく、レジストラの運用次第なので、ドメインを見ただけではわからない。従って Cookie でも Domain 属性に `Domain=tokyo.jp` と書いてあったとき、これが正規に取得されている `.jp` の Registerable Domain を正しく指定しているのか、そうではないのかがブラウザにはわからないのだ。

そこで Mozilla は、「どの組み合わせが eTLD として運用されているのか」を独自に集めてファイルに並べ、ブラウザにそれを読み込んでドメインのパースに使っていた。そのリストは Mozilla 以外のソフトウェアにもニーズがあるため、今はコミュニティ手動でオープンに管理されている。このリストを Public Suffix List(PSL) と言う。(今は [github](https://github.com/publicsuffix/list/blob/master/public_suffix_list.dat) でも公開されている)

- [Public Suffix List](https://publicsuffix.org/)

冒頭の解説にあるように、主にブラウザが「履歴をドメインごとに並べる」「URL バーで重要なドメインを表示する」そして「Domain 属性を適切に処理する」ために使われるとされている。

しかし、この PSL が Mozilla 発だったように、他のベンダも独自に PSL 相当のリストを持ちメンテナンスしていた。 Microsoft も独自に保持し、そこには `tokyo.jp` がレジストラでどう運用されているのか、が正確に反映されていなかったというのが Cookie Monster バグの実態と考えられる。

現在 Chrome は PSL を使い、 IE も 2014 年の [Windows 10 Technical Preview](https://mspoweruser.com/microsoft-brings-interoperable-top-level-domain-name-parsing-internet-explorer/) から PSL を見るようになった。つまり、現状最新のブラウザであれば PSL を見ていると言える。(それより古いブラウザについては注意が必要)


### PSL Amendments

都道府県型 JP ドメインも、かつては地域型 JP ドメインという、[違う運用](https://internet.watch.impress.co.jp/docs/news/523403.html)がされていた。そうした運用の変更について、レジストラは PSL に更新を要求(PSL Amendments Request)するべきであり、おそらくまともなレジストラはそれを行っている。もし不安なら、ドメインを取る前に PSL を確認してみるのがいいだろう。

そして、ドメインの使い方を運用しているのはレジストラだけではない。たとえば、サブドメインに任意のサービスをデプロイできる heroku や glitch といったサービスは、自身が所有するドメインを eTLD のように扱い、ユーザにサブドメインを付与していると言える。そして、そのユーザがサブドメインにデプロイした Cookie は `Domain=herokuapp.com` や `Domain=glitch.me` などが設定できると問題が生じる可能性があるのだ。そこで、こうしたサービスも PSL に申請しており、実際にエントリが登録されている。

もし、自身の所有するドメインのサブドメインをユーザに提供し、そこで Cookie が付与できるようなサービスがデプロイ可能な状態になるならば、 PSL への登録を行うべきである可能性もあるため検討が必要だ。

:::details eTLD+1
つまり、通常サービスが運用される単位は eTLD の左に一階層付与したドメイン、例えば `${好きな単語}.${eTLD}` となる。これを **eTLD+1** と表現することがある。

そして、(少なくとも Cookie の仕様では) Registerable Domain == eTLD+1 だ。

しかし、先の例で言う herokuapp.com や glitch.me は(サービス運用者が取得したように) Registerable Domain だが実運用上 eTLD+1 ではないため、そのあたりを意識してあえて eTLD+1 と使い分ける場合もあるように思う。
:::


## SameSite Cookie









「Cookie はサイトをまたいでも自動で送られる」という挙動は CSRF や Timing Attack 以外にも様々な攻撃に応用できる可能性がある。

そこで、サイトを跨いだ Cookie の送信を制限するために提案されたのが Cookie の SameSite 属性だ。 SameSite 属性には 3 つの値がある。

- Strict
- Lax
- None

まず、以下のように Strict を付与すると、その Cookie はサイトを跨ぐいかなるリクエストにも付与されなくなる。


```
Set-Cookie: session_id=YWxpY2U; SameSite=Strict;
```

この設定ならば CSRF や Timing Attack の発生は、ほとんど防ぐことができる。しかし、 session_id にこれをつけてしまうと、別のサイトから遷移してきた場合にも Cookie が送られないため、毎回未ログインの状態になってしまう。

そこで、画面遷移(正確には Top Level Navication)の場合にだけ、別のサイトからも Cookie を送り、 Form からの POST や、画像などサブリソースへのリクエストには付与しないよう緩和した設定が Lax だ。

この設定でもかなりの攻撃が緩和されるが、この属性だけに依存したセキュリティ対策は推奨されない。 CSRF 対策には依然 Token を付与するなどの実装を行い、多層防御の一環としてこの設定の導入を検討するべきだ。

一方で、安全側に倒す目的で、 Cookie の設定をデフォルトで Lax にするブラウザもある。この場合 Set-Cookie に明示的に SameSite が付与されていなくても自動で Lax と扱われるため、多くの攻撃が未然に防がれる一方、これまで他のサイトにも Cookie が自動で送信されていることを前提に作られていたサイトは、壊れてしまう場合がある。

これを防ぐためには、サイトをまたいでも自動で送ってほしい Cookie に対し明示的に None を付与することで、これまでの挙動を維持する。


```
Set-Cookie: session_id=YWxpY2U; SameSite=None;
```

以上を踏まえると、今後は基本的に `SameSite=Lax` を前提に開発を行い、それでは満たせない要件が有る場合に、セキュリティリリエスクを踏まえた上で明示的に `SameSite=None` を付与する設計を考慮すると良いだろう。




:::details Cookie の構成の推奨?
サブドメインを複数組み合わせてサービスを提供するのも、それらが認証情報を共有すのもわりと一般的だ。かつその構成はサービスによってまちまちなので、どういう Cookie に設計するのが良いのかという一般解は示すのが難しい。
現実には Domain 属性を設定しているサービスも多いが、それら全てが脆弱な作りかと言うと必ずしもそうではない。結局は、属性の性質を正しく理解し、リスクを踏まえた上で、サービスごとに解を見つけていくしか無い。つまりケースバイケースという話にしかなりえない。

本書では、そうした「ケースバイケースである」というわかりきった話ではなく、その「ケース」について考えるために踏まえるべき解説を、なるべく多く盛り込んでいきたい。
:::





















## Secure 属性と HTTPS への制限




平分である HTTP で通信すると、通信を盗聴された場合 Cookie ヘッダの値が漏洩する可能性がある。そうした攻撃を避けるためにも、 Cookie を用いた通信は暗号化が必須だ。

このとき、「Cookie を使う URL だけ暗号化する」や、「一部だけ `http://` でのアクセスが可能」といった構成には注意が必要だ。

まず、 Cookie は同じドメインに対して送られるため、ユーザをなんらかの方法で `http://` の URL にアクセスさせれば、盗聴できる可能性がある。そこで、 Cookie を付与する際に、 Secure 属性を付与し、暗号化されている経路でしか送らないようにクライアントに指示する。


```
Set-Cookie: session_id=YWxpY2U; Path=/; Secure;
```

これで `http://` でアクセス可能な URL があっても、盗聴のリスクを減らすことができるだろう。しかし、これだけでは防げない問題もある。

例えば攻撃者は、 `http://` でアクセスできる URL から盗聴ができなくても、通信を改ざんして以下のようなヘッダを追加し Cookie を付与することが可能だ。


```
Set-Cookie: session_id=bad-cookie; Path=/; Secure;
```

このヘッダを受け取ったクライアントは Cookie を保存し、 `https://` での通信にもこの Cookie を送ってしまう。


```
Cookie: session_id=bad-cookie
```

Cookie ヘッダは `http://` と `https://` どちらで付与されたかという情報を持たないため、これが改ざんされた Cookie なのかを見分けることはできない。これも先ほどと同様、 Session Fixation 攻撃などに応用できる。

これは、 `http://` へのリクエストを `https://` にリダイレクトするようにしても、最初の通信が狙われる場合があるため、 Session Fixation 対策だけでなく、 Preload HSTS などを併用することが望ましいだろう。

(TODO: preload hsts はリンクだけ)

:::details Person in the Middle は成立するか?
ネットワークを流れるパケットを盗聴や改竄するという Person in the Middle は、想像しているよりも簡単に発生し得る。あまり詳しくは書かないが、例えば自分がルータなどのネットワーク機器に触れる立場なら、そのルータに繋がったデバイスのパケットを見るのは容易なのが事実だ。

例えばモバイル WiFi ルータの名前を「その場所にありそうなフリー Wifi の名前」にして置いておけば、無料 Wifi があると思って繋いでくる人がいそうなことは容易に想像できるだろう。その状態で、流れてくる信号が平文だったら HTTP Body にあるパスワードも、 Header にある Cookie も、 HTML に埋め込まれた個人情報も全部見放題だ。

それらの行為を社会的に防ぐのが法律で、技術的に防ぐのが暗号化だ。近年 Web を始めインターネット全般が「全ての通信を暗号化する」ことでそうしたことを防ぐ方向に動いている。

(平成では Man in the Middle と呼ばれていたため、古い情報を探す際はそちらのほうが見つかりやすいかもしれない。)
:::







### Max-Age による有効期限

Cookie には有効期限があり、クライアントがその Cookie をいつまで送り続けるのかを `max-age` 属性に秒数で指定する。


```
Set-Cookie: session_id=YWxpY2U; Path=/; Max-Age=2592000
```

先程の Set-Cookie はこの指定がないが、その場合 Cookie はブラウザが閉じると消えるという挙動になる。なお、昔は今と違い用が済むとブラウザをいちいち閉じていたため、ブラウザが閉じるまでをセッションと呼び、そこから仕様では有効期限を指定しない Cookie を、 Session Cookie と呼ぶ。

現在では、ブラウザを閉じても明示的にログアウトしなければセッションは維持されて欲しいため、 session_id には長い期間を指定するのが普通だ。しかし、他のサイトの Cookie が増えていき、ブラウザに保存できる限界を超えると古いものから消されることがあるため、指定した時間確実に残ることは保証されない。通常一年以上を指定する意味はないだろう。

また、かつては Expire 属性に日付を指定し、そこまで有効にするという指定方法があった。


```
Set-Cookie: session_id=YWxpY2U; Path=/; Expires=Sun, 02 Feb 2020 02:02:02 GMT
```

しかし、 Expires は保存している OS の時間を元に計算されるため、 OS の時間設定をずらすことでごまかすことができるため、改善のために Max-Age が定義された。現在のブラウザのほとんどは Max-Age に対応しているが、対応していないブラウザのために両方送るサービスもある。




### HttpOnly と JS の API

Cookie は JS からアクセスすることもできる。

例えば、先程付与した session_id は、以下のように取得できる。


```js
document.cookie // "session_id=YWxpY2U"
```

全体が文字列として取得され、好きに書き換えて代入しなおせば上書きすることができる。ここには属性も含めることが可能だ。


```js
document.cookie = "Foo=Bar; Max-Age=1000; Path=/"
```

Max-Age や Path を指定することで、ページ遷移をまたいでもサイト全体で保存されるため、かつては LocalStorage の代わりに使われていた。

しかし、 XSS などにより意図しない JS が実行された場合、この API を用いて Cookie を窃取、改ざんすることが可能だ。これを防ぐためには、 HttpOnly 属性をつけることで、その Cookie がサーバとの通信では送られるが、 JS ではアクセスできないようすることができる。


```js
Set-Cookie: session_id=YWxpY2U; Path=/; HttpOnly;
```

LocalStorage が普及した現在、 Cookie の JS API を積極的に使う機会も減った。特に session_id のような値には、 必ず HttpOnly を付与する。









### Cookie Prefixes

ここまで何度か解説したように、 Cookie は別のドメインやパス、  `http://` 通信などによって書き換えられている可能性が常にある。そして Cookie ヘッダにはどのような属性で保存された値なのかという情報が一切ない。


```http
# Secure を指定して想定した正規のヘッダ
Set-Cookie: session_id=YWxpY2U; Secure

# 改竄され Secure を消されたヘッダ
Set-Cookie: session_id=YWxpY2U;

# どちらも同じ Cookie ヘッダで送られる
Cookie: session_id=YWxpY2U
```

保存されている属性の値も一緒に送られてくれば確認できるが、今更 Cookie ヘッダの仕様を変えるわけにはいかない。そこで提案されたのが Cookie Prefix という仕様だ。

まず、 Secure 属性が確実についていて欲しい Cookie は、その Cookie 名の頭に `__Secure-` という接頭辞をつける。すると、ブラウザはその Cookie に Secure 属性がついていない場合は保存しなくなる。攻撃者が Prefix を外したら、サービスが知っているキーと変わってしまうため外すことはできない。

逆を言えば、ブラウザから送られてくる `__Secure-` がついた Cookie は、確実に Secure 属性がついており `https://` でしか送られていないことが保証できるのだ。


```http
# 保存される
Set-Cookie: __Secure-session_id=YWxpY2U; Secure

# 保存されない
Set-Cookie: __Secure-session_id=YWxpY2U

# Secure 属性がついてることが保証される
Cookie: __Secure-session_id=YWxpY2U
```

これをさらに強力にしたのが `__Host-` だ。これは Secure 属性があり、 Path 属性が `/` で、 Doamin 属性が無い場合しか保存されなくなる。


```http
Set-Cookie: __Host-session_id=YWxpY2U; Secure; Path=/;
```

送られてくる Cookie は、 `http://` 通信で送られたり、サブドメインに送られてないことが保証でき、まさしく session_id の用途に利用できる。

ブラウザが対応していない場合は、単にそういうヘッダ名な Cookie として扱われるだけなので、互換を壊さないため、導入の敷居は低く、改竄に対する対策に利用することができる。


### Cookie の削除と Clear-Site-Data

Cookie の削除には、長らく明示的な API がなかったが。そこで、消したい Cookie の値を空にしつつ有効期限切れにするという方法がとられる。 session_id の場合は削除がセッションの終了になるため、ログアウト処理などで行われる。


```
Set-Cookie: session_id= Max-Age=0;
```

もし HttpOnly が付与されていない場合は、 JS の API から消すことも可能だ。


```
document.cookie="session_id=; Max-Age=0"
```

最近では、明示的にブラウザが保存している情報を削除する `Clear-Site-Data` ヘッダが提案されており、実装が進んでいる。このヘッダは localStorage やブラウザキャッシュの削除なども含まれているが、以下のように設定すればサイトに保存されている Cookie を全て削除することが可能だ。


```http
Clear-Site-Data: "cookies"
```


### Cookie の用途と属性のまとめ

Cookie の用途は session_id だけではない。例えばユーザごとの設定を保存する用途にも使用されてきた。


```http
# ユーザのテーマ設定の保存
Set-Cookie: theme=aqua
```

そうした設定も、リクエストに載せて送られてくることでサーバで分岐してレスポンスを変えることができるが、そうした情報もサーバ側で session_id に紐づいて保存されるか、 JS から扱いやすいように LocalStorage などに保存されるのが一般的になった。

したがって Cookie の中心的な用途は session_id であり、その理想的な設定の一例は以下のようになるだろう。

- 安全な乱数を元に生成した値を利用
- Path 属性を `/` にしサイト全体で利用
- Max-Age 属性を長めにして明示的にログアウトするまでセッションを維持
- Secure 属性を付与し https のみで送信されるように
- Domain 属性を付与せず、余計なサブドメインに送信しない
- HttpOnly 属性を付与し、 JS API からさわれないように
- SameSite 属性を Lax にし、画面遷移以外では別ドメインに送られないように


```http
Set-Cookie: __Host-session_id=YWxpY2U; Path=/; Max-Age=2592000; Secure; HttpOnly; SameSite=Lax
```
